<?xml version="1.0" encoding="UTF-8" ?>

<Section title="General"
         xmlns="urn:com.io7m.structural:8:0">

  <Subsection title="Potential Attack: API Resource Exhaustion">
    <Subsection title="Description">
      <Paragraph>
        An attacker with access to the APIs could send specially crafted messages designed to exhaust
        server resources during parsing/validation of the messages.
      </Paragraph>
    </Subsection>
    <Subsection title="Mitigation">
      <Paragraph>
        All APIs exposed by the <Term type="package">idstore</Term> server are defined using the
        <LinkExternal target="https://www.io7m.com/software/cedarbridge/">Cedarbridge</LinkExternal>
        protocol. Cedarbridge-based protocols have the following properties:
      </Paragraph>
      <FormalItem title="Cedarbridge Properties">
        <ListUnordered>
          <Item>
            Parsing and validation complexity is linear in the size of the parsed message. It is
            not possible to specify a message that will result in an exponentially complex parse.
            Additionally, the server currently places hard limits on message sizes from clients;
            <Term type="constant">1048576</Term> octets for commands, and
            <Term type="constant">1024</Term> octets for login requests.
          </Item>
          <Item>
            Cedarbridge protocols are very strongly-typed, operate under a closed-world
            assumption, and are immune to any kind of reflection-based deserialization vulnerabilities.
            Deserialization of messages cannot under any circumstances result in the deserialization of
            arbitrary objects.
          </Item>
          <Item>
            Cedarbridge protocols have a structure that is known ahead of time by both peers. Neither
            side gets to decide the structure of messages during communication. This is a common source
            of vulnerabilities in other protocols, where message types are self-describing on the wire
            and therefore a hostile client is able to transmit the description of a message that will
            cause the server to do an unbounded amount of work to parse and/or validate the message.
          </Item>
          <Item>
            Parsing code generated by the Cedarbridge compiler does not preallocate any structures.
            It is not possible, therefore, for a specially-crafted message to result in the server
            performing a huge allocation based on an attacker-provided size value. If a message claims
            to provide a string that is <Term type="constant">4294967295</Term> octets long, the parser
            will attempt to consume <Term type="constant">4294967295</Term> octets one at a time. This
            requires an attacker to actually provide <Term type="constant">4294967295</Term> octets
            over the network, and the attacker will run into a hard request size limit before this
            completes.
          </Item>
        </ListUnordered>
      </FormalItem>
    </Subsection>
  </Subsection>

  <Subsection title="Potential Attack: Offline Brute Force">
    <Subsection title="Description">
      <Paragraph>
        An attacker managing to compromise the database of the <Term type="package">idstore</Term>
        server will have access to the hashed passwords of all users.
      </Paragraph>
    </Subsection>
    <Subsection title="Mitigation">
      <Paragraph>
        The <Term type="package">idstore</Term> server currently hashes all user passwords using
        <LinkExternal target="https://www.rfc-editor.org/rfc/rfc2898">PBKDF2</LinkExternal> with
        a SHA-256 HMAC, with a default configuration of <Term type="expression">100000</Term> rounds
        and a NIST-recommended size of 16 bytes for salt values. This combination of algorithm and
        parameters is, at the time of writing, expected to be expensive enough to break to deter
        most attackers. The system never stores plain text passwords in any form, and all plain-text-carrying
        data types are carefully defined in a manner that prevents the possibility of plain-text passwords
        accidentally leaking into log files as they move through the system.
      </Paragraph>
      <Paragraph>
        The algorithm and parameters used are stored per-password and can therefore be upgraded
        on a per-password basis as stronger algorithms are standardized and become available in
        Java.
      </Paragraph>
    </Subsection>
  </Subsection>

</Section>
